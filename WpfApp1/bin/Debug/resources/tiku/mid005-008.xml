<?xml version="1.0" encoding="gb2312"?>
<PaperSetter checked="true">
    <PaperDetail xml:space="preserve"><PaperVersion>1</PaperVersion><PaperID>1</PaperID><PaperName>1</PaperName><PaperAuthor>1</PaperAuthor><PaperTotalTime unit="hour">3</PaperTotalTime><PaperStartTime zone="+8">1</PaperStartTime><PaperProblemSum>4</PaperProblemSum><PublicKey>MIHxMIGoBgcqhkjOOAQBMIGcAkEA/KaCzo4Syrom78z3EQ5SbbB4sF7ey80etKII864WF64B81uRpH5t9jQTxeEu0ImbzRMqzVDZkVG9xD7nN1kuFwIVAJYu3cw2nLqOuyYO5rahJtk0bjjFAkBnhHGyepz0TukaScUUfbGpqvJE8FpDTWSGkx0tFCcbnjUDC3H9c9oXkGmzLik1Yw4cIGI1TQ2iCmxBblC+eUykA0QAAkEA8ojKBedYrFoDBvrk2cvh998qmKFuHB0gXegkDXzHhk+yUprBGbpdLHVDWq8P7hPLyNPuviEvJoxz4x5kqiidgQ==</PublicKey><Signature>MCwCFEbf4n1Ojw7ZMrC0SITQAJny3t+sAhRUnE4/lG2Qt8r2O4sMtoPTT5fzcQ==</Signature><PaperReference><![CDATA[1]]></PaperReference><PaperDescribe><![CDATA[登陆及提交说明<BR>
请不要擅自操作键盘和鼠标，根据现场工作的人员的指示操作。<BR>
<BR>
<BR>
2)试题描述说明<BR>
试题主要是描述了一个问题，并请你用程序来解决这个问题。一般来说，你所编写的程序应该能够接受题目中所描述的数据，按照题目的描述处理这些数据，并且严格按照输出描述(The Output)中所述的格式输出结果。程序将提交到服务器进行打分。打分详情可见‘3)打分说明’部分。<BR>
试题主要分为六部分: <BR>
1.标题<BR>
包括试题的主标题，以及副标题Time Limit部分，Time Limit表示所提交的答题程序所能运行的最长时间，如果超过这个时间，程序无论输出是否正确，都将被裁判端判为Time Limit Exceed。<BR>
比如Time Limit是10 sec(10秒)。如果提交的答题程序运行时间超过10秒，则会被判为Time Limit Exceed，无论答题程序输出是否正确，也就是说在10秒内答题程序输出的结果正确或错误都不会得到任何提示。<BR>
<BR>
2.Descripiton<BR>
题目描述，作为题目的主要部分，对问题进行详细的说明。<BR>
<BR>
3.The Input<BR>
输入描述部分，这部分描述了输入数据及其格式和范围。输入答题程序的数据将严格按照这部分的描述。<BR>
<BR>
4.The Output<BR>
输出描述，这部分描述了答题程序所应该输出的数据及其格式。答题程序必须按照这部分的描述来输出，否则很有可能无法通过裁判端的测试。<BR>
<BR>
5.Sample Input<BR>
输入样例，以实例来说明输入数据的格式。请注意这里的数据只是作为实例，并不代表实际测试答题程序的数据是这些。因此能正确处理Sample中的数据并不代表程序一定能通过。不过，Sample数据一定是实际测试数据的子集，因此不能正确处理Sample就一定无法在裁判端通过。所以没有通过Sample的程序最好不要贸然提交。
<BR>
6.Sample Output<BR>
对应输入样例的输出数据，用来说明答题程序所应输出的格式。答题程序的输出应该严格按照这部分所示输出。比如：<BR>
在Sample Output中有两个整数独占一行，并且以空格分隔，如下：<BR>
2 3<BR>
那么如下的输出都是错误的：<BR>
a=2 b=3<BR>
或<BR>
2       3<BR>
或<BR>
3 2<BR>
必须严格按照Sample Output中所示的格式输出才有可能通过裁判端打分。<BR>
<BR>
3)打分说明<BR>
打分结果	评判标准<BR>
Compile Error	编译错<BR>
Time Limited Exceeded	程序运行超过时间限制<BR>
Run Time Error	程序运行错误<BR>
Wrong Answer	输出结果中关键数据错误<BR>
Presentation Error	格式错<BR>
Accepted	输出结果完全正确<BR>


4)程序编写说明<BR>
1.C/C++<BR>
首先，必须注意程序的main函数需要定义成int型，然后必须return 0。<BR>
其次，如果输入描述(The Output)中没有明确规定输入结束标志或说以EOF结束，那么可以使用如下格式来读入：<BR>
<BR>
while(cin>>a)或while(scanf("%d",&a)==1)<BR>
<BR>
注：这里while(scanf("%d",&a)==1)中的1是输入数据的数量，如果有两个则是：<BR>
while(scanf("%d %d",&a,&b)==2)<BR>
<BR>]]></PaperDescribe></PaperDetail>
    <ProblemList encrypted="0">
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 5 最高频率</Title>
            <Author>朱凯</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">明明的爸爸是一位著名的数学家。他在明明很小的时候就发现明明有过人的数学天赋，因此有意培养他对数学的兴趣。一次，明明的爸爸和明明玩起了一个数字游戏，这个游戏的名字叫“最高频率”。在游戏中，明明的爸爸要求明明在一串数字中，找出出现次数最多的那个数字，如果有多个数字出现的次数一样，则取最小的那个数字。明明很快就理解的游戏的规则，开始玩起来。明明的爸爸首先给了明明三个数字：3、2、1；明明很快就回答说：“1”（虽然3、2都出现一次，但是1是最小的数字，因此答案是1）。明明的爸爸很惊讶于明明的反应速度，开始加大游戏的难度，给出了由6个数字组成的数字串：2、1、3、4、5、2；明明眼珠子一转，脱口而出：“2”。明明的爸爸意识到简单的数字串很难难住明明，于是决定给出很长的一串字符串来考明明。但与此同时，明明爸爸面对这很长的数字串，也无法一时就统计出哪个数字出现的次数最高。于是就求助与你，让你帮他写一个程序，用来计算出出现次数最多的那个数字。&lt;p&gt;
明明的爸爸的问题可以归结为：给你一个数字串，里面有n个数字，输出这个数字串中出现次数最多的那个数字；如果有多个数字出现次数一样，则输出其中最小的那个数字。</Description>
                <InputSpec xml:space="preserve">你写的程序需要从标准输入设备（通常为键盘）中读入多组测试数据，每组测试数据仅占一行，每行开始有一个正整数n（1 ≤ n ≤ 200），表示数字串中有n个数字；之后有n个数字，表示数字串中的n个数，其中每个数都大于等于1且小于等于109；每个数字之间用一个空格隔开。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序需要计算出一组相应的运算结果，并将每组运算结果依次写入到标准输出设备（通常为启动该程序的文本终端，例如Windows中的命令行终端）中。每组运算结果为一个整数，即这个数字串中出现次数最多的那个数字；如果有多个数字出现次数一样，则输出其中最小的那个数字。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">1 100
</TestInput>
                    <TestOutput xml:space="preserve">100
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">5 5 3 77 23 10
</TestInput>
                    <TestOutput xml:space="preserve">3
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">9 76 19 1 2 55 37 38 55 76
</TestInput>
                    <TestOutput xml:space="preserve">55
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">100 41 97 64 100 29 104 38 98 12 44 95 95 71 107 61 51 25 62 97 46 51 84 52 43 72 62 41 16 28 95 57 56 31 98 109 2 37 9 95 104 103 51 82 83 73 44 71 11 93 48 27 34 102 87 17 99 33 61 29 8 106 65 80 82 68 76 20 32 14 98 56 45 50 19 60 60 46 81 83 28 49 83 104 44 56 70 16 6 71 18 4 99 96 103 37 88 58 102 49 41
</TestInput>
                    <TestOutput xml:space="preserve">95
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">200 103 95 19 68 44 30 7 106 103 56 71 35 84 42 0 109 47 63 37 12 6 90 31 46 25 17 5 64 71 62 70 50 1 54 106 20 87 51 77 7 57 77 33 43 95 109 89 78 21 108 42 86 6 50 23 18 20 31 62 5 30 89 14 77 98 103 95 81 82 40 61 36 24 20 86 41 68 99 88 64 31 4 53 19 18 108 80 48 87 27 98 43 8 43 97 1 10 17 43 54 9 26 15 71 30 79 19 96 28 53 64 8 14 49 29 32 5 25 13 43 53 47 54 43 78 10 38 18 10 106 58 101 9 8 69 97 12 82 58 82 98 89 40 67 38 31 15 8 16 71 32 104 72 35 88 96 72 46 65 53 59 12 84 96 101 98 92 61 11 89 37 96 62 79 15 42 70 90 103 29 41 58 91 109 75 33 52 25 92 55 28 76 17 107 42 22 99 64 91 29
</TestInput>
                    <TestOutput xml:space="preserve">43
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="005">#include &lt;iostream&gt;    //
using namespace std;    //

int main()       //
{
	int n,a;     //
	while ( cin&gt;&gt;n )   //
	{
		int hash[110] = {0};   //
		
		int max = -1;  //
		int value = 1000;  //
		for ( int i=0;i&lt;n;i++ )   //
		{
			cin&gt;&gt;a;  //
			hash[a]++;  //
			if ( hash[a] == max &amp;&amp; a &lt; value)
			{
				value = a;
			}
			else if ( hash[a] &gt; max)  //
			{
				max = hash[a];
				value = a;
			}
		}
		
		cout&lt;&lt;value&lt;&lt;endl;   //
	}
return 0;  //
}
</Solution>
        </ProblemArchive>
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 6 按要求输出序列</Title>
            <Author>孙辞海</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">明明的爸爸是一位著名的数学家。他在明明很小的时候就发现明明有过人的数学天赋，因此有意培养他对数学的兴趣。一次，明明的爸爸为了培养明明对数字的敏感，和明明玩起了一个数字游戏，这个游戏的名称叫“按要求输出序列”。在游戏中，明明的爸爸给了明明一串数字，要求明明首先把这串数字中重复出现的数字删除到仅剩一个，即相同的数字只保留一个，然后将这串数字从小到大进行排序。明明很快就理解了游戏的规则，开始玩起来。明明的爸爸首先给了明明三个数字：3、2、1；明明很快就回答说：“1、2、3”。明明的爸爸惊讶于明明的反应能力，开始加大游戏的难度，给出了由6个数字组成的数字串：2、1、4、3、5、2；明明眼珠子一转，脱口而出：“1、2、3、4、5”（由于“2”出现了两次，因此要删除一个，然后再排序输出。）。明明的爸爸意识到简单的数字串难不住明明，于是决定给出很长的一串数字串来考明明。但与此同时，明明爸爸面对这很长的数字串也无法一时计算出最后的结果，于是就求助于你，让你帮他写一个程序，用来计算出数字串最后的结果。
&lt;BR&gt;&lt;BR&gt;
明明的爸爸的问题可以归结为：给你一个数字串，里面有n个数字，首先对数字串中的数字进行处理，删除重复出现的数字（重复出现的数字只保留一个），然后对数字串从小到大进行排序，最后输出排序后的字符串。
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行开始有一个正整数n（1≤n≤200），表示数字串中有n个数字，之后是n个数字，n个数字都大于等于0且小于等于109，每个数字用一个空格隔开。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个排序后的数字串，数字串中的数字用一个空格隔开。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。&lt;BR&gt;&lt;BR&gt;

注：通常，显示屏为标准输出设备。 
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">1 100
</TestInput>
                    <TestOutput xml:space="preserve">100
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">5 4 2 2 7 6
</TestInput>
                    <TestOutput xml:space="preserve">2 4 6 7
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">9 76 19 1 2 55 37 38 55 76
</TestInput>
                    <TestOutput xml:space="preserve">1 2 19 37 38 55 76
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">100 41 97 64 100 29 104 38 98 12 44 95 95 71 107 61 51 25 62 97 46 51 84 52 43 72 62 41 16 28 95 57 56 31 98 109 2 37 9 95 104 103 51 82 83 73 44 71 11 93 48 27 34 102 87 17 99 33 61 29 8 106 65 80 82 68 76 20 32 14 98 56 45 50 19 60 60 46 81 83 28 49 83 104 44 56 70 16 6 71 18 4 99 96 103 37 88 58 102 49 41
</TestInput>
                    <TestOutput xml:space="preserve">2 4 6 8 9 11 12 14 16 17 18 19 20 25 27 28 29 31 32 33 34 37 38 41 43 44 45 46 48 49 50 51 52 56 57 58 60 61 62 64 65 68 70 71 72 73 76 80 81 82 83 84 87 88 93 95 96 97 98 99 100 102 103 104 106 107 109
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">200 103 95 19 68 44 30 7 106 103 56 71 35 84 42 0 109 47 63 37 12 6 90 31 46 25 17 5 64 71 62 70 50 1 54 106 20 87 51 77 7 57 77 33 43 95 109 89 78 21 108 42 86 6 50 23 18 20 31 62 5 30 89 14 77 98 103 95 81 82 40 61 36 24 20 86 41 68 99 88 64 31 4 53 19 18 108 80 48 87 27 98 43 8 43 97 1 10 17 43 54 9 26 15 71 30 79 19 96 28 53 64 8 14 49 29 32 5 25 13 43 53 47 54 43 78 10 38 18 10 106 58 101 9 8 69 97 12 82 58 82 98 89 40 67 38 31 15 8 16 71 32 104 72 35 88 96 72 46 65 53 59 12 84 96 101 98 92 61 11 89 37 96 62 79 15 42 70 90 103 29 41 58 91 109 75 33 52 25 92 55 28 76 17 107 42 22 99 64 91 29
</TestInput>
                    <TestOutput xml:space="preserve">0 1 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 35 36 37 38 40 41 42 43 44 46 47 48 49 50 51 52 53 54 55 56 57 58 59 61 62 63 64 65 67 68 69 70 71 72 75 76 77 78 79 80 81 82 84 86 87 88 89 90 91 92 95 96 97 98 99 101 103 104 106 107 108 109
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="006">#include &lt;iostream&gt;  //
#include &lt;cstdlib&gt;  //
using namespace std;   //

int cmp( const void *a,const void *b )  //
{
	int *aa = (int *)a;  //
	int *bb = (int *)b;  //
	return *aa - *bb;   //
}

int main()  //
{
	int n,a;   //
	while ( cin&gt;&gt;n )   //
	{
		bool hash[110] = { false };  //
		int array[110],cnt=0,i;  //
		for ( i=0;i&lt;n;i++ )   //
		{
			cin&gt;&gt;a;  //
			if ( hash[a] == false )  //
				array[cnt++] = a;  //
			hash[a] = true;  //
		}
		qsort( array,cnt,sizeof(int),cmp );   //
		for ( i=0;i&lt;cnt-1;i++ )  //
			cout&lt;&lt;array[i]&lt;&lt;" ";         //
		cout&lt;&lt;array[i]&lt;&lt;endl;  //
	}
return 0;  //
}
</Solution>
        </ProblemArchive>
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 7 特殊四位数</Title>
            <Author>孙辞海</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">数学一直是明明很喜欢的一门学科，不但上课认真听讲，而且还自己钻研。有一次，老师在课上讲了一种特殊的四位整数，这种整数有两个特性：第一，它是某一个自然数的平方；第二，它的千位数字与十位数字之和等于百位数字与个位数字之积。然后老师就举了一个例子：1156，1156是34的平方，且1156的千位数字1加上十位数字5等于百位数字1乘以个数数字6，即1+5=1*6。然后老师告诉同学，这是最小的一个符合以上两个特性的四位整数，接着老师就留下了作业，要让同学们回家后尽量多的找出符合这两个特性的特殊四位数。明明回家后，就开始找了起来，1157、1158、1159、……、3136，直到到了3136（3136=56*56，3+3=1*6），明明才找到了第二个这样的特殊四位数。明明觉得这样找下去不是办法，后面还有好几千个数字要一个一个试下来，这样一定无法在睡觉前完成。于是明明就求助于你，帮他写一个程序，从小到大求出所有的这样的特殊四位数，然后当明明想要第几个这样的特殊四位数时，你就能够很快的告诉他。&lt;BR&gt;
&lt;BR&gt;
如果把上述所有的特殊四位数按从小到大的顺序排列后记为S1，S2，…，Sn，…，即排在第1个位置上的特殊四位数记为S1，排在第2个位置上的特殊四位数记为S2，…，排在第n个位置上的特殊四位数记为Sn，那么明明的问题可以归结为：假如一个特殊四位数排在第n个位置上，那么这个特殊四位数Sn等于多少呢？
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行仅有一个正整数n（n不大于特殊四位数的个数），表示要求第n个特殊四位数Sn。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个正整数，表示与输入数据n相对应的那个特殊四位数Sn，每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。&lt;BR&gt;
&lt;BR&gt;
注：通常，显示屏为标准输出设备。
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">1
</TestInput>
                    <TestOutput xml:space="preserve">1156
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">2
</TestInput>
                    <TestOutput xml:space="preserve">3136
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">3
</TestInput>
                    <TestOutput xml:space="preserve">7921
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">1
</TestInput>
                    <TestOutput xml:space="preserve">1156
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">2
</TestInput>
                    <TestOutput xml:space="preserve">3136
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">3
</TestInput>
                    <TestOutput xml:space="preserve">7921
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="007">#include &lt;iostream&gt;    //
#include &lt;cmath&gt;
using namespace std;    //

void toArray( int n,int *p )  //
{
	int cnt = 0;    //
	while ( n )    //
	{
		p[cnt++] = n % 10;    //
		n /= 10;   //
	}
}

int yes( int n )  //
{
	int array[5];  //
	toArray( n,array );  //
	if ( array[3]+array[1] == array[2]*array[0] )  //
		return 1;    //[9]
	else
		return 0;  //
}

int sqrtTest(int n) 
{
	int t = (int)sqrt(double(n));
	if(t * t == n)
    {
		return 1;
	}
	else
	{
		return 0;
	}
}

int main()  //
{
	int n,i;  //
	int a[3];
	i = 0;
	for ( n=1000;n&lt;10000;n++ )   //
		if ( yes(n) &amp;&amp; sqrtTest(n))  //
		{
			a[i++] = n;
			
		}
	while(cin&gt;&gt;n)
	{
        cout&lt;&lt;a[n-1]&lt;&lt;endl;
    }
			
return 0;  //
}
</Solution>
        </ProblemArchive>
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 8 找到最大数</Title>
            <Author>孙辞海</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">算法在程序设计中是相当重要的一环，一个好的算法能够大大提高一个程序执行的效率，节省大量的时间。明明刚开始学习程序设计，接触算法不久。一天，老师布置了一个作业，要求对一串数字各不相同的数字串进行排序，大的在前，小的在后。明明回家后就开始研究起来，他想到了一个方法：“如果我把一串数字中最大的那个数字找出来，然后与第一个数字交换，这样的话我就能够确定排序后数字串中的第一个数字；接着，我从数字串中的第二个数字开始往后找，找到最大的一个，然后与第二个数字交换，这样的话我就能够确定排序后数字串中的第二个数字；以此类推，接着找到第三大的数字、第四大的数字、……，最终剩下的那个数字是最小的，与此同时，我也结束了对数字串的排序。”明明研究发现，他的这个想法中最重要的一环就是在一串数字中找到最大的那个，然后与第一个数字交换，可是明明毕竟刚刚开始学习程序设计不久，无法写出较复杂的程序，所以明明想让你这位程序设计专家帮他的忙，帮助他把这段核心程序写出来，然后明明只需模仿着写就可以了。&lt;BR&gt;
&lt;BR&gt;
明明的问题可以归结为：在一串数字串中，找到最大的那个数，然后与第一个数交换位置，最后输出该的数字串。例如有如下一个数字串：1 8 7 2 4，经过一次操作后得到的数字串为：8 1 7 2 4。
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据占二行，每组测试数据的第一行仅有一个正整数n（1≤n≤1200），表示要输入的数字串中数字的个数；每组测试数据的第二行有n个整数，每隔整数之间用一个空格隔开。当n=0的时候，输入结束。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为经过一次排序操作后的数字串，数字串中的数字用一个空格隔开。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。&lt;BR&gt;
&lt;BR&gt;
注：通常，显示屏为标准输出设备。 
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="zero">
                    <Terminator xml:space="preserve">0</Terminator>
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">5
1 8 7 2 4
</TestInput>
                    <TestOutput xml:space="preserve">8 1 7 2 4
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">10
23 48 12 34 32 333 2 5 988 43
</TestInput>
                    <TestOutput xml:space="preserve">988 48 12 34 32 333 2 5 23 43
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">9
76 19 1 2 55 37 38 55 78
</TestInput>
                    <TestOutput xml:space="preserve">78 19 1 2 55 37 38 55 76
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">100
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
</TestInput>
                    <TestOutput xml:space="preserve">100 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 1
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">200
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200
</TestInput>
                    <TestOutput xml:space="preserve">200 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 1
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="008">#include &lt;iostream&gt;    //

using namespace std;    //


void swap( int &amp;a,int &amp;b )    //
{
	int temp = a;   //
	a = b;  //
	b = temp;  //
}

int main()  //
{
	int n,array[210];   //
	while ( cin&gt;&gt;n )   //
	{
		if(n==0) break;
		int i;  //
		int max = -100000000, pos = -1;  //
		for ( i=0;i&lt;n;i++ )   //
		{
			cin&gt;&gt;array[i];  //
			if ( array[i] &gt; max ) {  //
				max = array[i];  //
				pos = i;  //
			}
		}
		swap( array[0],array[pos] );  //
		for ( i=0;i&lt;n-1;i++ )    //
			cout&lt;&lt;array[i]&lt;&lt;" ";  //
		cout&lt;&lt;array[i]&lt;&lt;endl;   //
	}
return 0; //
}
</Solution>
        </ProblemArchive>
    </ProblemList>
</PaperSetter>

