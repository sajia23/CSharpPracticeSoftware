<?xml version="1.0" encoding="gb2312"?>
<PaperSetter checked="true">
    <PaperDetail xml:space="preserve"><PaperVersion>1</PaperVersion><PaperID>1</PaperID><PaperName>1</PaperName><PaperAuthor>1</PaperAuthor><PaperTotalTime unit="hour">3</PaperTotalTime><PaperStartTime zone="+8">1</PaperStartTime><PaperProblemSum>4</PaperProblemSum><PublicKey>MIHxMIGoBgcqhkjOOAQBMIGcAkEA/KaCzo4Syrom78z3EQ5SbbB4sF7ey80etKII864WF64B81uRpH5t9jQTxeEu0ImbzRMqzVDZkVG9xD7nN1kuFwIVAJYu3cw2nLqOuyYO5rahJtk0bjjFAkBnhHGyepz0TukaScUUfbGpqvJE8FpDTWSGkx0tFCcbnjUDC3H9c9oXkGmzLik1Yw4cIGI1TQ2iCmxBblC+eUykA0QAAkEA8ojKBedYrFoDBvrk2cvh998qmKFuHB0gXegkDXzHhk+yUprBGbpdLHVDWq8P7hPLyNPuviEvJoxz4x5kqiidgQ==</PublicKey><Signature>MCwCFHB2IfbRXr6oOXHTvFBZJv3G+bNUAhQ2Xaa1z5PLxuxPjrhmcLMnf2ID+Q==</Signature><PaperReference><![CDATA[1]]></PaperReference><PaperDescribe><![CDATA[登陆及提交说明<BR>
请不要擅自操作键盘和鼠标，根据现场工作的人员的指示操作。<BR>
<BR>
<BR>
2)试题描述说明<BR>
试题主要是描述了一个问题，并请你用程序来解决这个问题。一般来说，你所编写的程序应该能够接受题目中所描述的数据，按照题目的描述处理这些数据，并且严格按照输出描述(The Output)中所述的格式输出结果。程序将提交到服务器进行打分。打分详情可见‘3)打分说明’部分。<BR>
试题主要分为六部分: <BR>
1.标题<BR>
包括试题的主标题，以及副标题Time Limit部分，Time Limit表示所提交的答题程序所能运行的最长时间，如果超过这个时间，程序无论输出是否正确，都将被裁判端判为Time Limit Exceed。<BR>
比如Time Limit是10 sec(10秒)。如果提交的答题程序运行时间超过10秒，则会被判为Time Limit Exceed，无论答题程序输出是否正确，也就是说在10秒内答题程序输出的结果正确或错误都不会得到任何提示。<BR>
<BR>
2.Descripiton<BR>
题目描述，作为题目的主要部分，对问题进行详细的说明。<BR>
<BR>
3.The Input<BR>
输入描述部分，这部分描述了输入数据及其格式和范围。输入答题程序的数据将严格按照这部分的描述。<BR>
<BR>
4.The Output<BR>
输出描述，这部分描述了答题程序所应该输出的数据及其格式。答题程序必须按照这部分的描述来输出，否则很有可能无法通过裁判端的测试。<BR>
<BR>
5.Sample Input<BR>
输入样例，以实例来说明输入数据的格式。请注意这里的数据只是作为实例，并不代表实际测试答题程序的数据是这些。因此能正确处理Sample中的数据并不代表程序一定能通过。不过，Sample数据一定是实际测试数据的子集，因此不能正确处理Sample就一定无法在裁判端通过。所以没有通过Sample的程序最好不要贸然提交。
<BR>
6.Sample Output<BR>
对应输入样例的输出数据，用来说明答题程序所应输出的格式。答题程序的输出应该严格按照这部分所示输出。比如：<BR>
在Sample Output中有两个整数独占一行，并且以空格分隔，如下：<BR>
2 3<BR>
那么如下的输出都是错误的：<BR>
a=2 b=3<BR>
或<BR>
2       3<BR>
或<BR>
3 2<BR>
必须严格按照Sample Output中所示的格式输出才有可能通过裁判端打分。<BR>
<BR>
3)打分说明<BR>
打分结果	评判标准<BR>
Compile Error	编译错<BR>
Time Limited Exceeded	程序运行超过时间限制<BR>
Run Time Error	程序运行错误<BR>
Wrong Answer	输出结果中关键数据错误<BR>
Presentation Error	格式错<BR>
Accepted	输出结果完全正确<BR>


4)程序编写说明<BR>
1.C/C++<BR>
首先，必须注意程序的main函数需要定义成int型，然后必须return 0。<BR>
其次，如果输入描述(The Output)中没有明确规定输入结束标志或说以EOF结束，那么可以使用如下格式来读入：<BR>
<BR>
while(cin>>a)或while(scanf("%d",&a)==1)<BR>
<BR>
注：这里while(scanf("%d",&a)==1)中的1是输入数据的数量，如果有两个则是：<BR>
while(scanf("%d %d",&a,&b)==2)<BR>
<BR>]]></PaperDescribe></PaperDetail>
    <ProblemList encrypted="0">
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 33 最大与最小</Title>
            <Author>ZhouMingLiang</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">明明喜欢玩游戏，而明明的爸爸也乐意陪明明玩各种各样的小游戏。但是在游戏中，明明的爸爸又十分注意培养明明的智力，他希望通过游戏，不仅让明明得到快乐，而且又能让明明学到一些知识，锻炼他的思维能力，为将来的发展打下基础。一天，明明的爸爸和明明做起了一个叫“最大与最小”的游戏，游戏的规则简单但却很有趣，就是有M个整数，构成一个圆环，然后要在这个圆环中找出连续N个相邻的数，目的是要让这N个数的和达到最大或者最小。&lt;BR&gt;&lt;BR&gt;

例如：一共有5个整数，分别是：1、2、11、4、5，在这5个数中，取连续的3个数，然后我们能够达到的最大值是20（11+4+5），最小值是8（5+1+2）。&lt;BR&gt;&lt;BR&gt;

明明显然对这个游戏非常感兴趣，但是玩了几次后，明明发现这个游戏又并不是那么容易了，因为随着整数个数的增加，不同的取数方法越来越多，要找到最大最小值的难度就越来越高，到最后明明就变得有些不耐烦了，明明的爸爸发现了这个问题，于是就找到了你，他请你来帮明明一把，写一个程序，把这个环中可能达到的最大最小值找出来，然后告诉明明，而明明只需要找到是哪几个连续的数组成了最大最小值即可，这样可以节约很多的时间。&lt;BR&gt;&lt;BR&gt;

明明爸爸的问题可以归结为：在一个由M个整数构成圆环中，找出N个相邻的数，使其和为最大或最小。
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据有二行，测试数据的第一行包含个两个整数M、N（1≤N≤M≤100），M表示圆环中整数的个数，N表示要连续取出的数的个数，M和N用一个空格隔开；测试数据的第二行有M个整数，即圆环中的数，每个数之间用一个空格隔开。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果有两行，第一行首先输出“Max=”（不包含双引号），然后紧跟一个整数，即圆环中连续N个数的最大值；第二行首先输出“Min=”（不包含双引号），然后紧跟一个整数，即圆环中连续N个数的最小值。每组运算结果的行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间有一个空行，最后一组运算结果后面没有空行。&lt;BR&gt;&lt;BR&gt;

注：通常，显示屏为标准输出设备。
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="middle">
</Seperator>
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">8 4
1 7 8 2 6 5 4 3
</TestInput>
                    <TestOutput xml:space="preserve">Max=23
Min=13
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">5 3
1 2 3 4 5
</TestInput>
                    <TestOutput xml:space="preserve">Max=12
Min=6
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">10 4
9 6 5 2 45 6 3 0 10 33
</TestInput>
                    <TestOutput xml:space="preserve">Max=58
Min=19
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">9 5
9 8 7 6 5 4 3 2 1
</TestInput>
                    <TestOutput xml:space="preserve">Max=35
Min=15
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">5 1
1 2 3 4 5
</TestInput>
                    <TestOutput xml:space="preserve">Max=5
Min=1
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="33">#include &lt;cstdio&gt;
#include &lt;memory&gt;
#include &lt;limits&gt;
#include &lt;algorithm&gt;
#define MAXM 200
using namespace std;

int data[MAXM+1];
int m,n,maxs,mins;

int main()
{
    int i,sum;
    int r=0;
    while(scanf("%d %d",&amp;m,&amp;n)!=EOF)
    {
        if(r!=0) printf("\n");
        r++;
        sum=0;
        for(i=0;i&lt;m;i++)
        {
            scanf("%d",&amp;data[i]);
            if(i&lt;n)
            {
                sum=sum+data[i];
            }
        }
        memcpy(data+m,data,m*sizeof(int));
        maxs=INT_MIN;
        mins=INT_MAX;
        for(i=0;i&lt;m;i++)
        {
            maxs=max(maxs,sum);
            mins=min(mins,sum);
            sum=sum-data[i]+data[i+n];
        }
        printf("Max=%d\n",maxs);
        printf("Min=%d\n",mins);
    }
    return 0;
}
</Solution>
        </ProblemArchive>
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 34 环</Title>
            <Author>ZhouMingLiang</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">明明喜欢玩游戏，而明明的爸爸也乐意陪明明玩各种各样的小游戏。但是在游戏中，明明的爸爸又十分注意培养明明的智力，他希望通过游戏，不仅能让明明得到快乐，而且又能让明明学到一些知识，锻炼他的思维能力，为将来的发展打下基础。一天，明明的爸爸和明明做起了一个叫“环”的游戏。游戏的内容很简单但却很有趣，就是有1到9九个整数，他们以任意的顺序排列成一个圆环，然后要在这个圆环中剪一刀，再分别按顺时针和逆时针次序排列成两个九位数。现在的要求是，得到的这两个九位数差的绝对值能被396整除，问一共有几种剪环的方法。&lt;BR&gt;&lt;BR&gt;

例如九个数的排列为：1、2、3、4、5、6、7、8、9，在1和9之间剪一刀（注意：因为是一个环，所以1和9是相邻的。），顺时针形成的数为：123456789，逆时针形成的数为：987654321，这两个数的差的绝对值为：864197532，这个数能被396整除，因此这是一种符合规则的剪法，更奇妙的是，这也是这种排序方式的唯一剪法。
&lt;BR&gt;&lt;BR&gt;
明明显然对这个游戏非常感兴趣，高兴地做起来。但是玩了几次后，明明发现这个游戏又并不是那么容易了，因为对于这九个数来说，虽然一共只有九种剪法，但是每种方法都要试，且还要做加法再做除法，他觉得非常的麻烦，玩着玩着就失去了兴趣。明明的爸爸发现了这个问题，于是就找到了你，他请你来帮明明一把，写一个程序，计算出某个排序中符合条件的剪法共有几种，这样的话可以大大鼓励明明玩游戏的兴致。&lt;BR&gt;&lt;BR&gt;

明明爸爸的问题可以归结为：将1至9这九个数字，以任意顺序排成一个环，请在某两个数字之间剪开，分别按顺时针和逆时针次序排列成两个九位数，要求剪开后所得到的这两个九位数的差能被396整除，问共有几种剪法？ 
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，输入的第一行有一个整数n，表示一共有多少组测试数据，接下来有n行，为n个测试数据，每组测试数据有9个数字，表示一种环的排列顺序，每个数字之间用一个空格隔开。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数，即有多少种符合条件的剪法。每组运算结果的行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。&lt;BR&gt;&lt;BR&gt;

注：通常，显示屏为标准输出设备。 
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="num">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">1 2 3 4 5 6 7 8 9
</TestInput>
                    <TestOutput xml:space="preserve">1
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">9 8 7 6 5 4 3 2 1
</TestInput>
                    <TestOutput xml:space="preserve">1
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">9 7 5 3 1 2 4 6 8
</TestInput>
                    <TestOutput xml:space="preserve">4
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">2 4 6 8 1 3 5 7 9
</TestInput>
                    <TestOutput xml:space="preserve">4
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">9 4 6 2 3 1 7 8 5
</TestInput>
                    <TestOutput xml:space="preserve">4
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="113.cpp">#include &lt;iostream&gt;
using namespace std;
#include &lt;cmath&gt;

int main()
{
    int sum[9];
    int i,j,n;
    int c,num1,num2;
    cin&gt;&gt;n;
    while(n--)
    {
        for(i=0;i&lt;9;i++)
            cin&gt;&gt;sum[i];
        
        c = 0;
        for(i=0;i&lt;9;i++)
        {
            num1 = num2 =0;
            for(j=i;j&lt;9;j++)
            {
                num1 = num1*10 + sum[j];
            }
            for(j=0;j&lt;i;j++)
            {
                num1 = num1*10 + sum[j];
            }
            
            for(j=i-1;j&gt;=0;j--)
            {
                num2 = num2*10 + sum[j];
            }
            for(j=8;j&gt;=i;j--)
            {
                num2 = num2*10 + sum[j];
            }
            if(labs(num1-num2)%396==0)
                c++;   
        }
        cout&lt;&lt;c&lt;&lt;endl;
    }
    return 0;
}
</Solution>
        </ProblemArchive>
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 35 三位素数</Title>
            <Author>ZhouMingLiang</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">明明的爸爸是一位数学家，明明受他爸爸的影响从小就喜欢数学，经常向他爸爸学习或请教数学问题。一天，明明问他爸爸什么是素数。明明的爸爸回答说：“首先，素数都是自然数，即都是大于1的整数；其次素数是只能被1和其本身整除的数，例如‘3’这个数，它只能被1和3这两个整数整除，因此‘3’就是素数；但是‘4’就不是素数，因为4除了能被1和4整除外，也能被2整除，因此‘4’就不是一个素数。”&lt;BR&gt;&lt;BR&gt;

聪明的明明很快就理解了爸爸的意思，但是明明爸爸为了使明明能够对素数产生更浓厚的兴趣，于是给明明讲了一种特殊的三位数的素数，这种三位数的素数有如下的性质：&lt;BR&gt;&lt;BR&gt;

1）	它本身是一个素数；&lt;BR&gt;
2）	它的逆序数也是一个素数；&lt;BR&gt;
3）	它的各位数字之和也是一个素数；&lt;BR&gt;
4）	它的各位数字之积或者是一个素数，或者是1，或者是0；&lt;BR&gt;&lt;BR&gt;

举个例子来讲：101这个数本身是一个素数，它的逆序数101也是素数，数码和是2，2是一个素数，数码积是0，符合条件，因此101是一个符合条件的三位素数。有趣的一点是，101还是所有三位特殊素数中最小的一个，原因很简单，因为100并不是一个素数。&lt;BR&gt;&lt;BR&gt;

现在明明的爸爸给了明明一个任务，要求明明找出符合以上条件的所有的三位特殊素数，并从小到大进行排列，然后当明明爸爸要明明说出第几个三位特殊素数是，明明就能够回答出来。如果把上述所有的三位特殊素数按从小到大的顺序排列后记为S&lt;SUB&gt;1&lt;/SUB&gt;，S&lt;SUB&gt;2&lt;/SUB&gt;，…，S&lt;SUB&gt;n&lt;/SUB&gt;，…，即排在第1个位置上的三位特殊素数记为S&lt;SUB&gt;1&lt;/SUB&gt;，排在第2个位置上的三位特殊素数记为S&lt;SUB&gt;2&lt;/SUB&gt;，…，排在第n个位置上的三位特殊素数记为S&lt;SUB&gt;n&lt;/SUB&gt;，那么明明的问题可以归结为：假如一个三位特殊素数排在第n个位置上，那么这个三位特殊素数S&lt;SUB&gt;n&lt;/SUB&gt;等于多少呢？
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行仅包括一个正整数N（N保证小于等于三位特殊素数的个数），代表要知道的那个三位特殊素数。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数，即所要知道的那个三位特殊素数。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。
&lt;BR&gt;&lt;BR&gt;
注：通常，显示屏为标准输出设备。
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">1
</TestInput>
                    <TestOutput xml:space="preserve">101
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">2
</TestInput>
                    <TestOutput xml:space="preserve">113
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">3
</TestInput>
                    <TestOutput xml:space="preserve">131
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">4
</TestInput>
                    <TestOutput xml:space="preserve">151
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">5
</TestInput>
                    <TestOutput xml:space="preserve">311
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="114.cpp">#include &lt;iostream&gt;
using namespace std;
#include &lt;cmath&gt;

bool prime(int n)
{ 
    int j,k;
    k=(int)sqrt((double)n);
    for(j=2;j&lt;=k;j++)
        if(n%j==0)
            break;
    if(j&gt;k) 
        return true;
    else 
        return false;
}

int main()
{
    int i,j;
    int t,n;
    int p[30];
    j=0;
    for(i=101;i&lt;1000;i++)
    {
        if(prime(i)
           &amp;&amp; prime(((i%10)*10+(i%100)/10)*10+i/100)
           &amp;&amp; prime(i%10+(i%100)/10+i/100)
           &amp;&amp; prime((i%10)*((i%100)/10)*(i/100)))
        {
            p[j++]=i;
        }
    }
    while(cin&gt;&gt;n)
    {
        cout&lt;&lt;p[n-1]&lt;&lt;endl;
    }
    
    return 0;
}
</Solution>
        </ProblemArchive>
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 36 矩阵转换</Title>
            <Author>ZhouMingLiang</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">明明是一个很聪明的孩子，学什么东西都很快。但是他也有个缺点，就是不愿意做重复的劳动，往往学会一样东西以后，就不太愿意再去碰它。有一天，明明在数学课上学了矩阵的转换，即有一个r×r的矩阵，把矩阵中的数以左上到右下的对角线的方式进行交换，然后形成一个新的矩阵。&lt;BR&gt;&lt;BR&gt;

例如：有个3×3的矩阵如下：&lt;BR&gt;&lt;BR&gt;

1 2 3&lt;BR&gt;
4 5 6&lt;BR&gt;
7 8 9&lt;BR&gt;&lt;BR&gt;

通过以左上到右下的对角线交换后，形成了一个新的矩阵：&lt;BR&gt;&lt;BR&gt;

1 4 7&lt;BR&gt;
2 5 8&lt;BR&gt;
3 6 9&lt;BR&gt;&lt;BR&gt;

明明很快就学会了，然后自己动手做了几个类似的转换。但是，课后老师布置了很多矩阵转换的作业，让同学回家练习，这就使明明很厌烦了，觉得自己已经学会了，就没有再练习的必要了。于是明明就请你帮个忙，帮他写一个程序，来计算矩阵的交换，帮他完成老师布置的作业。&lt;BR&gt;&lt;BR&gt;

明明的问题可以归结为：有一个r×r的矩阵，把矩阵中的数以左上到右下的对角线的方式进行转换，然后输出转换后的矩阵。
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据有多行，每组测试数据的第一行有一个整数r（1≤r≤10），表示一个r×r的矩阵，接下来有r行，每行有r个整数，表示要转换的矩阵中的数，每个数用一个空格隔开。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个转换后的矩阵。每组运算结果形成r行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间有一个空行，最后一组运算结果后面没有空行。&lt;BR&gt;&lt;BR&gt;

注：通常，显示屏为标准输出设备。 
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="middle">
</Seperator>
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">3
1 2 3
4 5 6
7 8 9
</TestInput>
                    <TestOutput xml:space="preserve">1 4 7
2 5 8
3 6 9
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">2
1 2
3 4
</TestInput>
                    <TestOutput xml:space="preserve">1 3
2 4
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
</TestInput>
                    <TestOutput xml:space="preserve">1 5 9 13
2 6 10 14
3 7 11 15
4 8 12 16
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">8
1 2 3 4 5 6 7 8
9 10 11 12 13 14 15 16
17 18 19 20 21 22 23 24
25 26 27 28 29 30 31 32
33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48
49 50 51 52 53 54 55 56
57 58 59 60 61 62 63 64
</TestInput>
                    <TestOutput xml:space="preserve">1 9 17 25 33 41 49 57
2 10 18 26 34 42 50 58
3 11 19 27 35 43 51 59
4 12 20 28 36 44 52 60
5 13 21 29 37 45 53 61
6 14 22 30 38 46 54 62
7 15 23 31 39 47 55 63
8 16 24 32 40 48 56 64
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">10
1 2 3 4 5 6 7 8 9 10
11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30
31 32 33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48 49 50
51 52 53 54 55 56 57 58 59 60
61 62 63 64 65 66 67 68 69 70
71 72 73 74 75 76 77 78 79 80
81 82 83 84 85 86 87 88 89 90
91 92 93 94 95 96 97 98 99 100
</TestInput>
                    <TestOutput xml:space="preserve">1 11 21 31 41 51 61 71 81 91
2 12 22 32 42 52 62 72 82 92
3 13 23 33 43 53 63 73 83 93
4 14 24 34 44 54 64 74 84 94
5 15 25 35 45 55 65 75 85 95
6 16 26 36 46 56 66 76 86 96
7 17 27 37 47 57 67 77 87 97
8 18 28 38 48 58 68 78 88 98
9 19 29 39 49 59 69 79 89 99
10 20 30 40 50 60 70 80 90 100
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">9
1 2 3 4 5 6 7 8 9
10 11 12 13 14 15 16 17 18
19 20 21 22 23 24 25 26 27
28 29 30 31 32 33 34 35 36
37 38 39 40 41 42 43 44 45
46 47 48 49 50 51 52 53 54
55 56 57 58 59 60 61 62 63
64 65 66 67 68 69 70 71 72
73 74 75 76 77 78 79 80 81
</TestInput>
                    <TestOutput xml:space="preserve">1 10 19 28 37 46 55 64 73
2 11 20 29 38 47 56 65 74
3 12 21 30 39 48 57 66 75
4 13 22 31 40 49 58 67 76
5 14 23 32 41 50 59 68 77
6 15 24 33 42 51 60 69 78
7 16 25 34 43 52 61 70 79
8 17 26 35 44 53 62 71 80
9 18 27 36 45 54 63 72 81
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="036">#include&lt;iostream&gt;   //
#include&lt;cstring&gt;   //

using namespace std;   //

int main()   //
{
	int r;   //
	int s[10][10];
	int i,j,k;   //
	int u=0;
	while(cin&gt;&gt;r)   //
	{
		if(u!=0) cout&lt;&lt;endl;
		u++;
		for(i=0;i&lt;r;i++)   //
			for (j=0;j&lt;r;j++)   //
				cin&gt;&gt;s[i][j];   //
		
		for(i=0;i&lt;r;i++)   //
			for (j=0+i;j&lt;r;j++)   //
			{
				if(i!=j)
				{
					k = s[j][i];
					s[j][i] = s[i][j];
					s[i][j] = k;
				}
			}

		for(i=0;i&lt;r;i++)   //
		{
			for (j=0;j&lt;r-1;j++)   //
			{
				cout&lt;&lt;s[i][j]&lt;&lt;" ";   //
			}
			cout&lt;&lt;s[i][j]&lt;&lt;endl;
		}
	}
	return 0;   //
}
</Solution>
        </ProblemArchive>
    </ProblemList>
</PaperSetter>

