<?xml version="1.0" encoding="gb2312"?>
<PaperSetter checked="true">
    <PaperDetail xml:space="preserve"><PaperVersion>1</PaperVersion><PaperID>1</PaperID><PaperName>1</PaperName><PaperAuthor>1</PaperAuthor><PaperTotalTime unit="hour">3</PaperTotalTime><PaperStartTime zone="+8">1</PaperStartTime><PaperProblemSum>4</PaperProblemSum><PublicKey>MIHxMIGoBgcqhkjOOAQBMIGcAkEA/KaCzo4Syrom78z3EQ5SbbB4sF7ey80etKII864WF64B81uRpH5t9jQTxeEu0ImbzRMqzVDZkVG9xD7nN1kuFwIVAJYu3cw2nLqOuyYO5rahJtk0bjjFAkBnhHGyepz0TukaScUUfbGpqvJE8FpDTWSGkx0tFCcbnjUDC3H9c9oXkGmzLik1Yw4cIGI1TQ2iCmxBblC+eUykA0QAAkEA8ojKBedYrFoDBvrk2cvh998qmKFuHB0gXegkDXzHhk+yUprBGbpdLHVDWq8P7hPLyNPuviEvJoxz4x5kqiidgQ==</PublicKey><Signature>MCwCFGepCQ9ApYKID7Z1EGWzCYow/0RbAhQVl63FWZlJCRVKRZy7mbLE+wvBag==</Signature><PaperReference><![CDATA[1]]></PaperReference><PaperDescribe><![CDATA[登陆及提交说明<BR>
请不要擅自操作键盘和鼠标，根据现场工作的人员的指示操作。<BR>
<BR>
<BR>
2)试题描述说明<BR>
试题主要是描述了一个问题，并请你用程序来解决这个问题。一般来说，你所编写的程序应该能够接受题目中所描述的数据，按照题目的描述处理这些数据，并且严格按照输出描述(The Output)中所述的格式输出结果。程序将提交到服务器进行打分。打分详情可见‘3)打分说明’部分。<BR>
试题主要分为六部分: <BR>
1.标题<BR>
包括试题的主标题，以及副标题Time Limit部分，Time Limit表示所提交的答题程序所能运行的最长时间，如果超过这个时间，程序无论输出是否正确，都将被裁判端判为Time Limit Exceed。<BR>
比如Time Limit是10 sec(10秒)。如果提交的答题程序运行时间超过10秒，则会被判为Time Limit Exceed，无论答题程序输出是否正确，也就是说在10秒内答题程序输出的结果正确或错误都不会得到任何提示。<BR>
<BR>
2.Descripiton<BR>
题目描述，作为题目的主要部分，对问题进行详细的说明。<BR>
<BR>
3.The Input<BR>
输入描述部分，这部分描述了输入数据及其格式和范围。输入答题程序的数据将严格按照这部分的描述。<BR>
<BR>
4.The Output<BR>
输出描述，这部分描述了答题程序所应该输出的数据及其格式。答题程序必须按照这部分的描述来输出，否则很有可能无法通过裁判端的测试。<BR>
<BR>
5.Sample Input<BR>
输入样例，以实例来说明输入数据的格式。请注意这里的数据只是作为实例，并不代表实际测试答题程序的数据是这些。因此能正确处理Sample中的数据并不代表程序一定能通过。不过，Sample数据一定是实际测试数据的子集，因此不能正确处理Sample就一定无法在裁判端通过。所以没有通过Sample的程序最好不要贸然提交。
<BR>
6.Sample Output<BR>
对应输入样例的输出数据，用来说明答题程序所应输出的格式。答题程序的输出应该严格按照这部分所示输出。比如：<BR>
在Sample Output中有两个整数独占一行，并且以空格分隔，如下：<BR>
2 3<BR>
那么如下的输出都是错误的：<BR>
a=2 b=3<BR>
或<BR>
2       3<BR>
或<BR>
3 2<BR>
必须严格按照Sample Output中所示的格式输出才有可能通过裁判端打分。<BR>
<BR>
3)打分说明<BR>
打分结果	评判标准<BR>
Compile Error	编译错<BR>
Time Limited Exceeded	程序运行超过时间限制<BR>
Run Time Error	程序运行错误<BR>
Wrong Answer	输出结果中关键数据错误<BR>
Presentation Error	格式错<BR>
Accepted	输出结果完全正确<BR>


4)程序编写说明<BR>
1.C/C++<BR>
首先，必须注意程序的main函数需要定义成int型，然后必须return 0。<BR>
其次，如果输入描述(The Output)中没有明确规定输入结束标志或说以EOF结束，那么可以使用如下格式来读入：<BR>
<BR>
while(cin>>a)或while(scanf("%d",&a)==1)<BR>
<BR>
注：这里while(scanf("%d",&a)==1)中的1是输入数据的数量，如果有两个则是：<BR>
while(scanf("%d %d",&a,&b)==2)<BR>
<BR>]]></PaperDescribe></PaperDetail>
    <ProblemList encrypted="0">
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 45 找出质数</Title>
            <Author>SunCiHai</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">明明学习数学已经有一段时间了。一次老师在课上讲了什么叫质数。质数就是大于等于2且只能被1和其本身整除的整数。明明觉得这很简单，以为这很容易掌握，于是就不多做练习。明的爸爸发现了这个问题，他想让明明多做练习，把质数这个知识点掌握牢固。但是，他也知道只是求质数会很无聊，明明一定不愿意多做。于是他想出了一个游戏，这个游戏叫“找出质数”，就是给明明一个数字串，要叫明明在这个数字串中找出一个最大的子串，要求这个子串是一个质数。&lt;BR&gt;&lt;BR&gt;

但是由于明明还太小，他的计算能力有限，因此明明的爸爸认为，找出长度大于4个字符的质数对明明来说太困难了。于是他降低了要求，只需找出小于10,000的最长的质数子串即可。&lt;BR&gt;&lt;BR&gt;

例如：有一个数字串为17，最大的子串就应该是17，因为1不是质数，7虽然是质数，但是7的长度只有1，17也是质数，它的长度为2，因此最大的子串就是17。&lt;BR&gt;&lt;BR&gt;

明明觉得这个游戏很有趣，就高兴地做了起来，明明的爸爸出了很多个数字串，由于数字串太多，所以明明爸爸自己找出最长的子串也要花很多的时间，于是明明的爸爸想让你帮他一个忙，写一个程序，找出数字串中最长的质数子串。&lt;BR&gt;&lt;BR&gt;

明明爸爸的问题可以归结为：输入一串数字，找出其中最长的不超过4个字符的质数子串。若有多个答案，则找出其中数值最大的一个。
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅一行，每组测试数据为一个数字串，数字串的长度不超过20。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数，即最长的不超过4个字符的质数子串（测试数据保证这个子串存在）；若有多个答案，则输出其中数值最大的一个。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。&lt;BR&gt;&lt;BR&gt;

注：通常，显示屏为标准输出设备。 
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">17
</TestInput>
                    <TestOutput xml:space="preserve">17
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">12
</TestInput>
                    <TestOutput xml:space="preserve">2
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">2346236
</TestInput>
                    <TestOutput xml:space="preserve">23
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">3464562
</TestInput>
                    <TestOutput xml:space="preserve">5
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">243523
</TestInput>
                    <TestOutput xml:space="preserve">523
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">456546
</TestInput>
                    <TestOutput xml:space="preserve">5
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">2462
</TestInput>
                    <TestOutput xml:space="preserve">2
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">456576
</TestInput>
                    <TestOutput xml:space="preserve">5657
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">567567
</TestInput>
                    <TestOutput xml:space="preserve">67
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">256257734734456
</TestInput>
                    <TestOutput xml:space="preserve">6257
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="45">#include &lt;iostream&gt;
using namespace std;

bool isprime(int x){
	for(int i=2;i&lt;x;i++){
		if(x%i==0) return false;
	}
	return true;
}

int main(){
	char str[100];
	while(cin.getline(str,100)){
		int i=strlen(str);
		if(i&gt;4) i=4;
		int max=-1;
		bool find=false;
		while(i&gt;0){
			for(int j=0;j&lt;=strlen(str)-i;j++){
				int sum=0;
				for(int cnt=0;cnt&lt;i;cnt++){
					sum=sum*10+str[j+cnt]-'0';
				}
				if(isprime(sum)&amp;&amp;sum&gt;max){
					max=sum;
					find=true;
				}
			}
			if(find) break;
			i--;
		}
		cout&lt;&lt;max&lt;&lt;endl;
	}
}</Solution>
        </ProblemArchive>
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 46 日期比较</Title>
            <Author>SunCiHai</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">“明明，今天是哪年哪月哪日？”明明的爸爸问道。&lt;BR&gt;
	“2008年6月22号。”明明回答。&lt;BR&gt;
	“那明天呢？”明明的爸爸继续问道。&lt;BR&gt;
	“2008年6月23号。”明明回答。&lt;BR&gt;
	“那后天呢？”&lt;BR&gt;
	“2008年6月24号。”&lt;BR&gt;
	……&lt;BR&gt;
	“2008年6月22号是不是在2008年6月23号前面？”明明的爸爸问。&lt;BR&gt;
	“是啊，这有什么好问的？？”明明有些不耐烦。&lt;BR&gt;
	“2008年6月24号是不是在2008年6月23号后面？”明明的爸爸又问。&lt;BR&gt;&lt;BR&gt;

	接着明明的爸爸又问了很多类似的问题。明明终于烦了，他很奇怪爸爸怎么问这些问题。这时，明明的爸爸终于说出了他想说的话：“明明，你是不是觉得这些问题很简单，爸爸怎么会问这些问题？”明明说：“是的。”明明的爸爸接着说：“我想告诉你的是，人是会觉得烦的，因为人有一定的忍耐限度，一直问一个人同一个类似的问题，人会被搞的很烦躁，但是电脑就不会，即使你问他一百遍、一千遍相同的问题，电脑都不会烦，它会耐心地一次一次地回答你同一个问题。你能不能帮爸爸写一个程序，告诉程序两个日期，程序就能比较这两个日期中哪个在前哪个在后”明明想了想说：“没问题。”于是就去写程序了。&lt;BR&gt;&lt;BR&gt;

	明明爸爸的问题可以归结为：写一个程序，输入两个合法日期，比较这个两日期哪个在日历中靠前。（具体输出格式见Output）
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据两行，每组测试数据的第一行为第一个日期，日期的格式为dd mm yyyy，dd表示日，mm表示月，yyyy表示年，中间用一个空格隔开，每组测试数据的第二行为第二个日期，格式与第一个日期一样，每组测试数据的两个日期保证是不同的并且合法。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一句话，格式如下：“01 01 1999 is earlier than 02 02 1999”。首先输出靠前的日期，接着输出“ is earlier than ”，然后在输出靠后的日期，注意，小于10的日期、月份之前要加0。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。&lt;BR&gt;&lt;BR&gt;

注：通常，显示屏为标准输出设备。 
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">01 01 1999
02 02 1999
</TestInput>
                    <TestOutput xml:space="preserve">01 01 1999 is earlier than 02 02 1999
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">11 11 1111
12 12 1212
</TestInput>
                    <TestOutput xml:space="preserve">11 11 1111 is earlier than 12 12 1212
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">02 21 1999
03 23 1242
</TestInput>
                    <TestOutput xml:space="preserve">03 23 1242 is earlier than 02 21 1999
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">01 01 2000
01 02 2000
</TestInput>
                    <TestOutput xml:space="preserve">01 01 2000 is earlier than 01 02 2000
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">02 01 2000
1 2 2000
</TestInput>
                    <TestOutput xml:space="preserve">02 01 2000 is earlier than 01 02 2000
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">01 01 2000
01 01 2001
</TestInput>
                    <TestOutput xml:space="preserve">01 01 2000 is earlier than 01 01 2001
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">01 01 2000
02 01 2000
</TestInput>
                    <TestOutput xml:space="preserve">01 01 2000 is earlier than 02 01 2000
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">01 1 2000
1 12 2000
</TestInput>
                    <TestOutput xml:space="preserve">01 01 2000 is earlier than 01 12 2000
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">01 11 2000
01 02 2000
</TestInput>
                    <TestOutput xml:space="preserve">01 02 2000 is earlier than 01 11 2000
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">11 01 2000
01 02 2000
</TestInput>
                    <TestOutput xml:space="preserve">11 01 2000 is earlier than 01 02 2000
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="46">#include &lt;iostream&gt;
using namespace std;
int a1,a2,a3,b1,b2,b3;
void printa(){
	printf("%02d %02d %d is earlier than %02d %02d %d\n",a1,a2,a3,b1,b2,b3);
}
void printb(){
	printf("%02d %02d %d is earlier than %02d %02d %d\n",b1,b2,b3,a1,a2,a3);
}
int main(){
	while(cin&gt;&gt;a1&gt;&gt;a2&gt;&gt;a3  &gt;&gt;b1&gt;&gt;b2&gt;&gt;b3){
		if(a3&lt;b3) printa();
		else if(b3&lt;a3) printb();
		else if(a2&lt;b2) printa();
		else if(b2&lt;a2) printb();
		else if(a1&lt;b1) printa();
		else printb();
	}
	return 0;
}</Solution>
        </ProblemArchive>
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 47 魔方阵</Title>
            <Author>SunCiHai</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">在一次数学课上，明明的老师讲了一种非常有趣的方阵，称之为三阶魔方阵。它是一个三行三列，由1、2、3、……8、9，九个数字共同构成，且它每行、每列、两对角线之和均相等，于是一个合法的三阶魔方阵就形成了以下的方阵：&lt;BR&gt;&lt;BR&gt;

8 1 6&lt;BR&gt;
3 5 7&lt;BR&gt;
4 9 2&lt;BR&gt;&lt;BR&gt;

	富有钻研精神的明明回家后，马上就对三阶魔方阵进行研究。他总结出了5条n阶魔方阵的规律(n为奇数)，如下：&lt;BR&gt;
（1） 将“1”放在第一行中间一列；&lt;BR&gt;
（2） 从“2”开始直到n*n为止各数依次按下列规则存放：每一个数存放的行的行数比前一个数的行数减1，每一个数存放的列的列数比前一个数的列数加1，即前一个数的右上方。&lt;BR&gt;
（3） 如果上一数的行数为1，则下一个数的行数为n（指最下面一行）；&lt;BR&gt;
（4） 当上一个数的列数为n时，下一个数的列数应为1（指最左一列）；&lt;BR&gt;
（5） 如果按上面规则确定的位置上已有数，或上一个数是第一行第n列时，则把下一个数放在上一个数的下面。&lt;BR&gt;
	有了以上的方法，明明就可以轻易地构造出任意的n阶魔方阵。例如构造3阶魔方阵的过程如下：&lt;BR&gt;
先将1放在第一行的中间一列：&lt;BR&gt;
放1：（参考规则1）&lt;BR&gt;
* 1 *&lt;BR&gt;
* * *&lt;BR&gt;
* * *&lt;BR&gt;
放2：（参考规则3）&lt;BR&gt;
* 1 *&lt;BR&gt;
* * *&lt;BR&gt;
* * 2&lt;BR&gt;
放3：（参考规则4）&lt;BR&gt;
* 1 *&lt;BR&gt;
3 * *&lt;BR&gt;
* * 2&lt;BR&gt;
放4：（参考规则5）&lt;BR&gt;
* 1 *&lt;BR&gt;
3 * *&lt;BR&gt;
4 * 2&lt;BR&gt;
放5：（参考规则2）&lt;BR&gt;
* 1 *&lt;BR&gt;
3 5 *&lt;BR&gt;
4 * 2&lt;BR&gt;
放6：（参考规则2）&lt;BR&gt;
* 1 6&lt;BR&gt;
3 5 *&lt;BR&gt;
4 * 2&lt;BR&gt;
放7：（参考规则5）&lt;BR&gt;
* 1 6&lt;BR&gt;
3 5 7&lt;BR&gt;
4 * 2&lt;BR&gt;
放8：（参考规则4）&lt;BR&gt;
8 1 6&lt;BR&gt;
3 5 7&lt;BR&gt;
4 * 2&lt;BR&gt;
放9：（参考规则3）&lt;BR&gt;
8 1 6&lt;BR&gt;
3 5 7&lt;BR&gt;
4 9 2&lt;BR&gt;&lt;BR&gt;

	但是随着n的不断增大，构建一个n阶魔方阵所花的精力就越多。于是明明就请你帮忙，帮助他用程序来构建n阶魔方阵。&lt;BR&gt;&lt;BR&gt;

	明明的问题可以归结为：给你一个阶数n，请你按照题目中描述的方法，构造出n阶魔方阵。 
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行仅包括一个正整数n（1≤n≤19，且n是奇数），表示要构造的魔方阵阶数。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。输出时，每组运算结果为n阶魔方阵。每组运算结果与其后一组运算结果之间有一个空行，最后一组运算结果后面没有空行。&lt;BR&gt;&lt;BR&gt;

注：通常，显示屏为标准输出设备。
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="middle">
</Seperator>
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">1
</TestInput>
                    <TestOutput xml:space="preserve">1
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">3
</TestInput>
                    <TestOutput xml:space="preserve">8 1 6
3 5 7
4 9 2
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">5
</TestInput>
                    <TestOutput xml:space="preserve">17 24 1 8 15
23 5 7 14 16
4 6 13 20 22
10 12 19 21 3
11 18 25 2 9
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">7
</TestInput>
                    <TestOutput xml:space="preserve">30 39 48 1 10 19 28
38 47 7 9 18 27 29
46 6 8 17 26 35 37
5 14 16 25 34 36 45
13 15 24 33 42 44 4
21 23 32 41 43 3 12
22 31 40 49 2 11 20
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">9
</TestInput>
                    <TestOutput xml:space="preserve">47 58 69 80 1 12 23 34 45
57 68 79 9 11 22 33 44 46
67 78 8 10 21 32 43 54 56
77 7 18 20 31 42 53 55 66
6 17 19 30 41 52 63 65 76
16 27 29 40 51 62 64 75 5
26 28 39 50 61 72 74 4 15
36 38 49 60 71 73 3 14 25
37 48 59 70 81 2 13 24 35
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">11
</TestInput>
                    <TestOutput xml:space="preserve">68 81 94 107 120 1 14 27 40 53 66
80 93 106 119 11 13 26 39 52 65 67
92 105 118 10 12 25 38 51 64 77 79
104 117 9 22 24 37 50 63 76 78 91
116 8 21 23 36 49 62 75 88 90 103
7 20 33 35 48 61 74 87 89 102 115
19 32 34 47 60 73 86 99 101 114 6
31 44 46 59 72 85 98 100 113 5 18
43 45 58 71 84 97 110 112 4 17 30
55 57 70 83 96 109 111 3 16 29 42
56 69 82 95 108 121 2 15 28 41 54
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">13
</TestInput>
                    <TestOutput xml:space="preserve">93 108 123 138 153 168 1 16 31 46 61 76 91
107 122 137 152 167 13 15 30 45 60 75 90 92
121 136 151 166 12 14 29 44 59 74 89 104 106
135 150 165 11 26 28 43 58 73 88 103 105 120
149 164 10 25 27 42 57 72 87 102 117 119 134
163 9 24 39 41 56 71 86 101 116 118 133 148
8 23 38 40 55 70 85 100 115 130 132 147 162
22 37 52 54 69 84 99 114 129 131 146 161 7
36 51 53 68 83 98 113 128 143 145 160 6 21
50 65 67 82 97 112 127 142 144 159 5 20 35
64 66 81 96 111 126 141 156 158 4 19 34 49
78 80 95 110 125 140 155 157 3 18 33 48 63
79 94 109 124 139 154 169 2 17 32 47 62 77
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">15
</TestInput>
                    <TestOutput xml:space="preserve">122 139 156 173 190 207 224 1 18 35 52 69 86 103 120
138 155 172 189 206 223 15 17 34 51 68 85 102 119 121
154 171 188 205 222 14 16 33 50 67 84 101 118 135 137
170 187 204 221 13 30 32 49 66 83 100 117 134 136 153
186 203 220 12 29 31 48 65 82 99 116 133 150 152 169
202 219 11 28 45 47 64 81 98 115 132 149 151 168 185
218 10 27 44 46 63 80 97 114 131 148 165 167 184 201
9 26 43 60 62 79 96 113 130 147 164 166 183 200 217
25 42 59 61 78 95 112 129 146 163 180 182 199 216 8
41 58 75 77 94 111 128 145 162 179 181 198 215 7 24
57 74 76 93 110 127 144 161 178 195 197 214 6 23 40
73 90 92 109 126 143 160 177 194 196 213 5 22 39 56
89 91 108 125 142 159 176 193 210 212 4 21 38 55 72
105 107 124 141 158 175 192 209 211 3 20 37 54 71 88
106 123 140 157 174 191 208 225 2 19 36 53 70 87 104
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">17
</TestInput>
                    <TestOutput xml:space="preserve">155 174 193 212 231 250 269 288 1 20 39 58 77 96 115 134 153
173 192 211 230 249 268 287 17 19 38 57 76 95 114 133 152 154
191 210 229 248 267 286 16 18 37 56 75 94 113 132 151 170 172
209 228 247 266 285 15 34 36 55 74 93 112 131 150 169 171 190
227 246 265 284 14 33 35 54 73 92 111 130 149 168 187 189 208
245 264 283 13 32 51 53 72 91 110 129 148 167 186 188 207 226
263 282 12 31 50 52 71 90 109 128 147 166 185 204 206 225 244
281 11 30 49 68 70 89 108 127 146 165 184 203 205 224 243 262
10 29 48 67 69 88 107 126 145 164 183 202 221 223 242 261 280
28 47 66 85 87 106 125 144 163 182 201 220 222 241 260 279 9
46 65 84 86 105 124 143 162 181 200 219 238 240 259 278 8 27
64 83 102 104 123 142 161 180 199 218 237 239 258 277 7 26 45
82 101 103 122 141 160 179 198 217 236 255 257 276 6 25 44 63
100 119 121 140 159 178 197 216 235 254 256 275 5 24 43 62 81
118 120 139 158 177 196 215 234 253 272 274 4 23 42 61 80 99
136 138 157 176 195 214 233 252 271 273 3 22 41 60 79 98 117
137 156 175 194 213 232 251 270 289 2 21 40 59 78 97 116 135
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">19
</TestInput>
                    <TestOutput xml:space="preserve">192 213 234 255 276 297 318 339 360 1 22 43 64 85 106 127 148 169 190
212 233 254 275 296 317 338 359 19 21 42 63 84 105 126 147 168 189 191
232 253 274 295 316 337 358 18 20 41 62 83 104 125 146 167 188 209 211
252 273 294 315 336 357 17 38 40 61 82 103 124 145 166 187 208 210 231
272 293 314 335 356 16 37 39 60 81 102 123 144 165 186 207 228 230 251
292 313 334 355 15 36 57 59 80 101 122 143 164 185 206 227 229 250 271
312 333 354 14 35 56 58 79 100 121 142 163 184 205 226 247 249 270 291
332 353 13 34 55 76 78 99 120 141 162 183 204 225 246 248 269 290 311
352 12 33 54 75 77 98 119 140 161 182 203 224 245 266 268 289 310 331
11 32 53 74 95 97 118 139 160 181 202 223 244 265 267 288 309 330 351
31 52 73 94 96 117 138 159 180 201 222 243 264 285 287 308 329 350 10
51 72 93 114 116 137 158 179 200 221 242 263 284 286 307 328 349 9 30
71 92 113 115 136 157 178 199 220 241 262 283 304 306 327 348 8 29 50
91 112 133 135 156 177 198 219 240 261 282 303 305 326 347 7 28 49 70
111 132 134 155 176 197 218 239 260 281 302 323 325 346 6 27 48 69 90
131 152 154 175 196 217 238 259 280 301 322 324 345 5 26 47 68 89 110
151 153 174 195 216 237 258 279 300 321 342 344 4 25 46 67 88 109 130
171 173 194 215 236 257 278 299 320 341 343 3 24 45 66 87 108 129 150
172 193 214 235 256 277 298 319 340 361 2 23 44 65 86 107 128 149 170
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="47">#include &lt;iostream&gt;
using namespace std;
int main(){
	int n;
	int r=0;
	while(cin&gt;&gt;n){
		if(r!=0) cout&lt;&lt;endl;
		r++;
		int a[n][n];
		memset(a,0,sizeof(a));
		int x=n/2;
		int y=0;
		for(int num=1;num&lt;=n*n;num++){
			a[y][x]=num;
			int tx=x+1;
			if(tx&gt;=n) tx=0;
			int ty=y-1;
			if(ty&lt;0) ty=n-1;
			if(a[ty][tx]!=0){
				y=y+1;
				if(y&gt;=n) y=0;
			}
			else{
				x=tx;
				y=ty;
			}
		}
		for(int i=0;i&lt;n;i++){
			cout&lt;&lt;a[i][0];
			for(int j=1;j&lt;n;j++){
				cout&lt;&lt;" "&lt;&lt;a[i][j];
			}
			cout&lt;&lt;endl;
		}
	}
}</Solution>
        </ProblemArchive>
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 48 最长的单词</Title>
            <Author>ZhuKai</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">明明刚开始学习英语的时候，对英语有浓厚的兴趣，但是随着时间的推移，英语单词量的增加，明明越来越觉得背单词是一件相当痛苦的事情。于是他想出各种各样的方法来增加背单词的乐趣。这次他想出的方法是把所有要背的英语单词排成一行，找出其中最长的一个单词来先背，然后划去这个单词，在剩下的单词中再找出一个最长的单词来背，以此类推，直到把所有单词都背完。如果有多个长度相同的单词，则先背一行中靠前的那个单词。这样做的好处是：背到越后面，单词越短，越容易背，越能增加背单词的信心。&lt;BR&gt;&lt;BR&gt;

例如有这么一行单词：&lt;BR&gt;
one two three four five&lt;BR&gt;&lt;BR&gt;

	明明会首先挑出three来背，因为它是最长的一个单词，由5个字母组成；然后明明会选择four这个单词，虽然five这个单词的长度和four这个单词的长度一样，但是four在five的前面，所以明明会先背four这个单词，然后再背five，等明明把five这个单词背完以后，接着背one这个单词，最后背的是two这个单词。&lt;BR&gt;&lt;BR&gt;

	但是在这样背单词之中，明明又发现了另一个问题，当要背非常多的单词时，寻找最长的单词会花很多时间，他想让你帮助他写一个程序，找出一行单词中最长的那个，节约明明背单词所花的时间，与此同时，明明希望你能告诉他这个英文单词有多少个字母组成，那他可以做到心里有数。&lt;BR&gt;&lt;BR&gt;

	明明的问题可以归结为：在一行英文单词中，找出其中最长的单词（若有多个最长，找出第一个出现的），并输出这个单词的长度。 
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行包括许多个英语单词和空格，单词和单词之间可能有多个空格，每行的长度不会超过1000个字符。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数和一个英语单词，整数表示该英文单词的长度，整数和单词之间用一个空格隔开。输出时，每组运算结果单独占一行，其行首和行尾都没有任何空格或其他任何字符，每组运算结果与其后一组运算结果之间没有任何空行或其他任何字符，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行或其他任何字符。&lt;BR&gt;&lt;BR&gt;

注：通常，显示屏为标准输出设备。 
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">a bc def ghijk lmn
</TestInput>
                    <TestOutput xml:space="preserve">5 ghijk
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">abc def ghi
</TestInput>
                    <TestOutput xml:space="preserve">3 abc
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">aaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccccccccccccccccccccccccccccccccccdddddddddddddddddddddddddAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDD
</TestInput>
                    <TestOutput xml:space="preserve">219 aaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccccccccccccccccccccccccccccccccccdddddddddddddddddddddddddAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDD
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">dong hua univ ersi ty
</TestInput>
                    <TestOutput xml:space="preserve">4 dong
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">acm icpc is a programming contest
</TestInput>
                    <TestOutput xml:space="preserve">11 programming
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">Linear Work Suffix Array Construction
</TestInput>
                    <TestOutput xml:space="preserve">12 Construction
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">juha karkkainen peter sanders stefan burkhardt
</TestInput>
                    <TestOutput xml:space="preserve">10 karkkainen
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">suffix trees and suffix arrays are widely used and largely interchangeable index structures on string s and sequences
</TestInput>
                    <TestOutput xml:space="preserve">15 interchangeable
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">Practitioners prefer suffix arrays due to their simplicity and space efficiency while theoreticians use suffix trees due to linear time construction algorithms and more explicit structure
</TestInput>
                    <TestOutput xml:space="preserve">13 Practitioners
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">We narrow this gap between theory and practice with a simple linear time construction algorithm for suffix arrays
</TestInput>
                    <TestOutput xml:space="preserve">12 construction
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="048.cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;

using namespace std;

int main() {
    char temp[1000], rs[1000];
    while( cin.getline(temp, 1000) ) {
        int maxLen = 0;
        for(char* p = strtok(temp, " \n"); p; p = strtok(NULL, " \n")) {
            int len = strlen(p);
            if(len &gt; maxLen) {
                maxLen = len;
                strcpy(rs, p);
            }
        }
        cout &lt;&lt; maxLen &lt;&lt; " " &lt;&lt; rs &lt;&lt; endl;
    }
    return 0;
}
</Solution>
        </ProblemArchive>
    </ProblemList>
</PaperSetter>

