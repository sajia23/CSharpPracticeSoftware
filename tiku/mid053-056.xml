<?xml version="1.0" encoding="gb2312"?>
<PaperSetter checked="true">
    <PaperDetail xml:space="preserve"><PaperVersion>1</PaperVersion><PaperID>1</PaperID><PaperName>1</PaperName><PaperAuthor>1</PaperAuthor><PaperTotalTime unit="hour">3</PaperTotalTime><PaperStartTime zone="+8">1</PaperStartTime><PaperProblemSum>4</PaperProblemSum><PublicKey>MIHxMIGoBgcqhkjOOAQBMIGcAkEA/KaCzo4Syrom78z3EQ5SbbB4sF7ey80etKII864WF64B81uRpH5t9jQTxeEu0ImbzRMqzVDZkVG9xD7nN1kuFwIVAJYu3cw2nLqOuyYO5rahJtk0bjjFAkBnhHGyepz0TukaScUUfbGpqvJE8FpDTWSGkx0tFCcbnjUDC3H9c9oXkGmzLik1Yw4cIGI1TQ2iCmxBblC+eUykA0QAAkEA8ojKBedYrFoDBvrk2cvh998qmKFuHB0gXegkDXzHhk+yUprBGbpdLHVDWq8P7hPLyNPuviEvJoxz4x5kqiidgQ==</PublicKey><Signature>MC0CFQCAgcu78vzS5IL295UGh7DAnRcKKwIUc2fiyRjLeu0nq38LZmguVAVS+CY=</Signature><PaperReference><![CDATA[1]]></PaperReference><PaperDescribe><![CDATA[登陆及提交说明<BR>
请不要擅自操作键盘和鼠标，根据现场工作的人员的指示操作。<BR>
<BR>
<BR>
2)试题描述说明<BR>
试题主要是描述了一个问题，并请你用程序来解决这个问题。一般来说，你所编写的程序应该能够接受题目中所描述的数据，按照题目的描述处理这些数据，并且严格按照输出描述(The Output)中所述的格式输出结果。程序将提交到服务器进行打分。打分详情可见‘3)打分说明’部分。<BR>
试题主要分为六部分: <BR>
1.标题<BR>
包括试题的主标题，以及副标题Time Limit部分，Time Limit表示所提交的答题程序所能运行的最长时间，如果超过这个时间，程序无论输出是否正确，都将被裁判端判为Time Limit Exceed。<BR>
比如Time Limit是10 sec(10秒)。如果提交的答题程序运行时间超过10秒，则会被判为Time Limit Exceed，无论答题程序输出是否正确，也就是说在10秒内答题程序输出的结果正确或错误都不会得到任何提示。<BR>
<BR>
2.Descripiton<BR>
题目描述，作为题目的主要部分，对问题进行详细的说明。<BR>
<BR>
3.The Input<BR>
输入描述部分，这部分描述了输入数据及其格式和范围。输入答题程序的数据将严格按照这部分的描述。<BR>
<BR>
4.The Output<BR>
输出描述，这部分描述了答题程序所应该输出的数据及其格式。答题程序必须按照这部分的描述来输出，否则很有可能无法通过裁判端的测试。<BR>
<BR>
5.Sample Input<BR>
输入样例，以实例来说明输入数据的格式。请注意这里的数据只是作为实例，并不代表实际测试答题程序的数据是这些。因此能正确处理Sample中的数据并不代表程序一定能通过。不过，Sample数据一定是实际测试数据的子集，因此不能正确处理Sample就一定无法在裁判端通过。所以没有通过Sample的程序最好不要贸然提交。
<BR>
6.Sample Output<BR>
对应输入样例的输出数据，用来说明答题程序所应输出的格式。答题程序的输出应该严格按照这部分所示输出。比如：<BR>
在Sample Output中有两个整数独占一行，并且以空格分隔，如下：<BR>
2 3<BR>
那么如下的输出都是错误的：<BR>
a=2 b=3<BR>
或<BR>
2       3<BR>
或<BR>
3 2<BR>
必须严格按照Sample Output中所示的格式输出才有可能通过裁判端打分。<BR>
<BR>
3)打分说明<BR>
打分结果	评判标准<BR>
Compile Error	编译错<BR>
Time Limited Exceeded	程序运行超过时间限制<BR>
Run Time Error	程序运行错误<BR>
Wrong Answer	输出结果中关键数据错误<BR>
Presentation Error	格式错<BR>
Accepted	输出结果完全正确<BR>


4)程序编写说明<BR>
1.C/C++<BR>
首先，必须注意程序的main函数需要定义成int型，然后必须return 0。<BR>
其次，如果输入描述(The Output)中没有明确规定输入结束标志或说以EOF结束，那么可以使用如下格式来读入：<BR>
<BR>
while(cin>>a)或while(scanf("%d",&a)==1)<BR>
<BR>
注：这里while(scanf("%d",&a)==1)中的1是输入数据的数量，如果有两个则是：<BR>
while(scanf("%d %d",&a,&b)==2)<BR>
<BR>]]></PaperDescribe></PaperDetail>
    <ProblemList encrypted="0">
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 53 回文数2</Title>
            <Author>ZhuKai</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">有一天，明明正在做作业，发现了一组很有趣的数字，例如1、11、313等等。他发现这些数字都是左右对称的，即不论你把这些数字从左读到右还是从右读到左，读出来的数字都是一样的。于是明明就把这个发现告诉了他爸爸。明明的爸爸是一名数学家，对此类型数字早有研究。他对明明说：“这些是回文数，是一种特殊的数字，即这些数字的左右两边是对称的。例如：11左右两边对称，313左右也是对称的。”&lt;BR&gt;
明明觉得这很有趣，接着问他爸爸还有什么和这类回文数有关的有趣的东西。明明的爸爸就说：“你把这些回文数转换成二进制数，看看是不是也符合回文数的规则。”明明发现1的二进制数也是1，符合回文数的规则；11的二进制数是1011，不符合回文数的规则；33的回文数是100001，符合回文数的规则。明明就回答爸爸说：“1和33的二进制数符合回文数的规则，11的二进制数则不符合回文数的规则。”&lt;BR&gt;
明明爸爸很满意明明的回答，又给了明明很多十进制数，让他判断在这些数中哪些数既是十进制回文数又是二进制回文数。明明起先做起来很有意思，但是时间一长就失去了兴趣。他想请你帮个忙，帮他写一个程序，用来判断一个数，它的十进制数是回文数，且它的二进制数也是回文数。&lt;BR&gt;
    明明的问题可以归结为：给你一个整数（十进制），判断该整数的十进制数和它的二进制数是否全为回文数。
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅有一行，每行有一个整数N（0 &amp;lt; N &amp;lt; 1000），表示要判断回文数的那个数。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为“Yes”或“No”，如果该数的十进制数和二进制数都是回文数，则输出“Yes”（不含双引号），否则输出“No”（不含双引号）。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。&lt;BR&gt;&lt;BR&gt;

注：通常，显示屏为标准输出设备。
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">1
</TestInput>
                    <TestOutput xml:space="preserve">Yes
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">10
</TestInput>
                    <TestOutput xml:space="preserve">No
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">33
</TestInput>
                    <TestOutput xml:space="preserve">Yes
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">2
</TestInput>
                    <TestOutput xml:space="preserve">No
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">3
</TestInput>
                    <TestOutput xml:space="preserve">Yes
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">999
</TestInput>
                    <TestOutput xml:space="preserve">No
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">585
</TestInput>
                    <TestOutput xml:space="preserve">Yes
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">0
</TestInput>
                    <TestOutput xml:space="preserve">Yes
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">1000
</TestInput>
                    <TestOutput xml:space="preserve">No
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">717
</TestInput>
                    <TestOutput xml:space="preserve">Yes
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="053.cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;//strlen

using namespace std;

void int2Str(int n, int base, char* str) {
    int i = 0, bound = base;
    do {
        str[i] = '0' + n % base;
        i++;
        n /= base;
    } while (n &gt; 0);
    str[i] = '\0';
}

bool isPalin(const char* str) {
    int len = strlen(str);
    for (int i = 0; i &lt; len / 2; i++) {
        if (str[i] != str[len - 1 - i]) {
            return false;
        }
    }
    return true;
}

int main() {
    int n;
    char dec[100], bin[100];
    while (cin &gt;&gt; n) {
        int2Str(n, 10, dec);
        int2Str(n, 2, bin);
        if ( isPalin(dec) &amp;&amp; isPalin(bin) ) {
            cout &lt;&lt; "Yes" &lt;&lt; endl;
        }
        else {
            cout &lt;&lt; "No" &lt;&lt; endl;
        }
    }
    return 0;
}
</Solution>
        </ProblemArchive>
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 54 加法器</Title>
            <Author>frankhuhu</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">明明读小学的时候，不喜欢数学，尤其是不喜欢做加法，一做加法就头疼，这样导致明明长大后数学依然不好，而且对数字产生了抵触心理。可是不巧的是，明明进了一家会计公司，每天都要计算很多数据，在这些计算中加法运算居多，而且这些加法不只是是两个数之间的加法，更有多个数的连加。
&lt;BR&gt;&lt;BR&gt;
    例如：1+2+3的正确答案是6。&lt;BR&gt;&lt;BR&gt;

    这给明明造成了很大的麻烦。你是明明的好朋友，看到明明如此痛苦，就产生了帮助明明的想法。你想帮明明写一个程序，这个程序能计算一串正整数的连加，从而帮助明明摆脱数字的困扰。&lt;BR&gt;&lt;BR&gt;

    明明的问题可以归结为：给你一串正整数的连加表达式，完成这个表达式的计算。
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅有一行，每行有一个表达式，表达式由正整数和加号（“+”）组成，不含其他任何符号，表达式中的数字小于等于30000,表达式的长度不超过1000，具体格式见输入样例。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数，即表达式的值。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。&lt;BR&gt;&lt;BR&gt;

注：通常，显示屏为标准输出设备。
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">1+2+3
</TestInput>
                    <TestOutput xml:space="preserve">6
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">5+111
</TestInput>
                    <TestOutput xml:space="preserve">116
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">1+2+3+4+5+6+7+8+9+10
</TestInput>
                    <TestOutput xml:space="preserve">55
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">10+9+8+7+6+5+4+3+2+1
</TestInput>
                    <TestOutput xml:space="preserve">55
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">101+289
</TestInput>
                    <TestOutput xml:space="preserve">390
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+30000+9999
</TestInput>
                    <TestOutput xml:space="preserve">4989999
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="054">#include&lt;iostream&gt;
#include&lt;cstdlib&gt;//atoi
#include&lt;cstring&gt;//strtok

using namespace std;

int main()
{
    char *p;
    char temp[1001];
    int sum, tint;
    while( cin.getline(temp, 1001) )
    {
        sum = 0;
        for(p = strtok(temp, "+"); p; p = strtok(NULL, "+"))
        {
              tint = atoi(p);
              sum += tint;
        }
        cout &lt;&lt; sum &lt;&lt; endl;
    }
    return 0;
}</Solution>
        </ProblemArchive>
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 55 数列1</Title>
            <Author>frankhuhu</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">思维的严密性是相当重要的，尤其是在程序设计中，一个小小的错误，就可能导致无法想象的后果。明明的爸爸是一名富有经验的程序设计专家，深知思维严密的重要性。于是在明明很小的时候，就通过游戏的方式训练明明的思维严密性。今天，明明的爸爸和明明做了一个数列的游戏。这个游戏很简单，就是有一数列，现在需要在数列中选出一个或者连续若干个数，要求这些数的和能被11整除。明明的爸爸想锻炼明明思维的严密性，因此要求明明尽可能多的找出符合条件的数列来，最好一个也不要漏掉。&lt;BR&gt;&lt;BR&gt;

    例如有一数列为“11 22 33”，其中11可以被11整除，22可以被11整除，33可以被11整除，11+22=33能被11整除，22+33=55能被11整除，11+22+33=66能被11整除。所以以上一数列能被11整除的情况一共有六种。（注：虽然11+33也能被11整除，但是11和33在数列中没有连续出现，因此不算一种合理的情况。）&lt;BR&gt;&lt;BR&gt;

    明明对这个游戏很感兴趣，高兴地玩了起来。由于粗心，明明总是无法一次就把所有的情况都找出来，这使得他爸爸不是很满意。于是明明爸爸决定先降低游戏的难度，事先告诉明明某一数列总共有多少种符合条件的选择数的方法，然后再让明明去选。明明的爸爸请你帮一个忙，他不想自己找出所有的情况，因此请你写一个程序，用程序来找出一共有多少种符合选数的情况，并把结果告诉他。&lt;BR&gt;&lt;BR&gt;

    明明爸爸的问题可以归结为：给你一个数列，从中选出1个或连续若干个数，要求这些数的和能被11整除，问这样的选数方法一共有多少种。
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据有两行，每组测试数据的第一行有一个整数n(0&amp;lt;n≤50)，表示数字串中有多少个整数，每组测试数据的第二行有n个整数，整数大于等于0且小于等于100，整数之间用一个空格隔开。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。 </InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数，即表示一共有多少种选数方法。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。&lt;BR&gt;&lt;BR&gt;

注：通常，显示屏为标准输出设备。 
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">1
11
</TestInput>
                    <TestOutput xml:space="preserve">1
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">2
11 22
</TestInput>
                    <TestOutput xml:space="preserve">3
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">10
1 1 1 1 1 1 1 1 1 1
</TestInput>
                    <TestOutput xml:space="preserve">0
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">11
1 1 1 1 1 1 1 1 1 1 1
</TestInput>
                    <TestOutput xml:space="preserve">1
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">3
11 22 33
</TestInput>
                    <TestOutput xml:space="preserve">6
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">50
3 8 3 8 3 8 3 8 3 8 3 8 3 8 3 8 3 8 3 8 3 8 3 8 1 1 4 7 4 7 4 7 4 7 4 7 4 7 4 7 4 7 4 7 4 7 4 7 4 7
</TestInput>
                    <TestOutput xml:space="preserve">288
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="055">#include&lt;iostream.h&gt;//
int arr[100];//
int main(){ //
    int n; //
    while(cin&gt;&gt;n){//
        int i,j,cnt=0;//
        for(i=0;i&lt;n;i++)cin&gt;&gt;arr[i]; //
        for(i=0;i&lt;n;i++){ int sum=0; //
        	for(j=i;j&lt;n;j++){ //
        		sum+=arr[j]; //
    			if(sum%11==0) //
    				cnt++;	//
			}			
		}
		cout&lt;&lt;cnt&lt;&lt;endl; //
    }
    return 0;    //
}  
</Solution>
        </ProblemArchive>
        <ProblemArchive version="1.0" checked="true">
            <Title>Problem 56 数列2</Title>
            <Author>frankhuhu</Author>
            <Problem contentType="html">
                <Description xml:space="preserve">思维的严密性是相当重要的，尤其是在程序设计中，一个小小的错误，就可能导致无法想象的后果。明明的爸爸是一名富有经验的程序设计专家，深知思维严密的重要性，于是在明明很小的时候，就通过游戏的方式，训练明明的思维严密性。今天，明明的爸爸和明明做了一个数列的游戏。这个游戏很简单，就是有一数列，现在需要在这数列中选出一个或者若干个数（可以不连续），要求这些数的和能被11整除。明明的爸爸想锻炼明明思维的严密性，因此要求明明尽可能多的找出符合条件的数列来，最好一个也不要漏掉。&lt;BR&gt;&lt;BR&gt;

    例如一数列为“11 22 33”，其中11可以被11整除，22可以被11整除，33可以被11整除，11+22=33能被11整除，22+33=55能被11整除，11+33=44能被11整除，11+22+33=66能被11整除。所以以上一数列能被11整除的情况一共有7种。&lt;BR&gt;&lt;BR&gt;

    明明对于这个游戏很感兴趣，高兴地玩了起来。由于粗心，明明总是无法一次就把所有的情况都找出来，这使得他爸爸不是很满意。于是明明爸爸决定先降低游戏的难度，事先告诉明明某一数列总共有多少种符合条件的选择数字的方法，然后再让明明去选。明明的爸爸请你帮一个忙，他不想自己找出所有的情况，因此请你写一个程序，用程序来找出一共有多少种符合选数的情况，并把结果告诉他。&lt;BR&gt;&lt;BR&gt;

    明明爸爸的问题可以归结为：给你一个数列，从中选出1个或若干个数（可以不连续），要求这些数的和能被11整除，问这样的选数方法一共有多少种。
</Description>
                <InputSpec xml:space="preserve">你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据有两行，每组测试数据的第一行有一个整数n(0&amp;lt;n≤15)，表示数列中有多少个整数，每组测试数据的第二行有n个整数，整数的大小都大于等于0且小于等于100，整数之间用一个空格隔开。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。</InputSpec>
                <OutputSpec xml:space="preserve">对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数，即表示一共有多少种选数方法。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。
&lt;BR&gt;&lt;BR&gt;
注：通常，显示屏为标准输出设备。 
</OutputSpec>
            </Problem>
            <TestData>
                <TimeLimit>10</TimeLimit>
                <InputFile />
                <OutputFile />
                <InputFormat inputType="eof">
                    <Terminator xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </InputFormat>
                <OutputFormat>
                    <Header xml:space="preserve" />
                    <Footer xml:space="preserve" />
                    <Seperator xml:space="preserve" layout="bottom" />
                </OutputFormat>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">1
11
</TestInput>
                    <TestOutput xml:space="preserve">1
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">2
11 22
</TestInput>
                    <TestOutput xml:space="preserve">3
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">5
1 33 5 100 4
</TestInput>
                    <TestOutput xml:space="preserve">3
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">10
1 2 3 4 5 6 7 8 9 10
</TestInput>
                    <TestOutput xml:space="preserve">93
</TestOutput>
                </TestCase>
                <TestCase difficulty="special">
                    <TestInput xml:space="preserve">8
11 22 33 44 55 66 77 88
</TestInput>
                    <TestOutput xml:space="preserve">255
</TestOutput>
                </TestCase>
                <TestCase difficulty="sample">
                    <TestInput xml:space="preserve">3
11 22 33
</TestInput>
                    <TestOutput xml:space="preserve">7
</TestOutput>
                </TestCase>
                <TestCase difficulty="trivial">
                    <TestInput xml:space="preserve">15
1 2 3 4 5 6 7 8 9 10 95 96 97 98 99
</TestInput>
                    <TestOutput xml:space="preserve">2977
</TestOutput>
                </TestCase>
            </TestData>
            <Solution xml:space="preserve" language="cpp" filename="056">#include&lt;iostream.h&gt;//
int arr[20]; //
int main(){ //
    int n; //
    while(cin&gt;&gt;n){ //
        int i,j,cnt=0;  //
        for(i=0;i&lt;n;i++) //
        cin&gt;&gt;arr[i]; //
        for(i=1;i&lt;=((1&lt;&lt;n)-1);i++){ //
            int tmp=i,res=0; //
            j=0; //
            while(tmp&gt;0){ //
                if(tmp&amp;1) res+=arr[j]; //
                tmp&gt;&gt;=1;  //
                j++; //
            }    
            if(res%11==0) //
            cnt++; //
        }  
        cout&lt;&lt;cnt&lt;&lt;endl;  //
    }    
    return 0; //
}    
</Solution>
        </ProblemArchive>
    </ProblemList>
</PaperSetter>

